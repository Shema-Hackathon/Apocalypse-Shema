const { Pool } = require('pg');
require('dotenv').config();

// Méthode 1 : Utiliser l'URL complète
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: {
    rejectUnauthorized: false
  }
});

// Méthode 2 : OU utiliser les variables séparées
const pool = new Pool({
  user: process.env.PGUSER,
  password: process.env.PGPASSWORD,
  host: process.env.PGHOST,
  database: process.env.PGDATABASE,
  port: process.env.PGPORT,
  ssl: {
    rejectUnauthorized: false
  }
});

app.post('/api/auth/register', async (req, res) => {
  try {
      const { email, password, display_name } = req.body;
      // Hachage du mot de passe (à implémenter avec bcrypt)
      const password_hash = password; // Temporaire - utiliser bcrypt
      
      const result = await pool.query(
          'INSERT INTO users (email, password_hash, display_name) VALUES ($1, $2, $3) RETURNING id, email, display_name',
          [email, password_hash, display_name]
      );
      
      res.json({ success: true, user: result.rows[0] });
  } catch (error) {
      res.status(500).json({ success: false, error: error.message });
  }
});

app.post('/api/auth/login', async (req, res) => {
  try {
      const { email, password } = req.body;
      const result = await pool.query(
          'SELECT * FROM users WHERE email = $1 AND password_hash = $2',
          [email, password] // Temporaire - utiliser bcrypt
      );
      
      if (result.rows.length === 0) {
          return res.status(401).json({ success: false, error: 'Identifiants invalides' });
      }
      
      res.json({ success: true, user: result.rows[0] });
  } catch (error) {
      res.status(500).json({ success: false, error: error.message });
  }
});

// Routes pour les symboles
app.get('/api/symbols', async (req, res) => {
  try {
      const result = await pool.query('SELECT * FROM apocalyptic_symbols ORDER BY name');
      res.json({ success: true, symbols: result.rows });
  } catch (error) {
      res.status(500).json({ success: false, error: error.message });
  }
});

app.get('/api/symbols/:id', async (req, res) => {
  try {
      const result = await pool.query('SELECT * FROM apocalyptic_symbols WHERE id = $1', [req.params.id]);
      res.json({ success: true, symbol: result.rows[0] });
  } catch (error) {
      res.status(500).json({ success: false, error: error.message });
  }
});

// Route pour initialiser les données des symboles
app.post('/api/init-symbols', async (req, res) => {
  try {
      const symbols = [
          {
              name: "La Bête",
              description: "Symbole des forces du mal et de l'opposition à Dieu",
              image_url: "https://raw.githubusercontent.com/Shema-Hackathon/Apocalypse-Shema/main/images/beast.jpg",
              bible_references: "Apocalypse 13:1-10",
              meaning: "Représente les empires persécuteurs et l'antichrist"
          },
          {
              name: "Les 7 Sceaux",
              description: "Les jugements divins progressifs",
              image_url: "https://raw.githubusercontent.com/Shema-Hackathon/Apocalypse-Shema/main/images/seven_seals.jpg", 
              bible_references: "Apocalypse 6:1-17, 8:1-5",
              meaning: "Symbolisent la souveraineté de Dieu sur l'histoire"
          }
          // Ajouter d'autres symboles...
      ];

      for (const symbol of symbols) {
          await pool.query(
              `INSERT INTO apocalyptic_symbols (name, description, image_url, bible_references, meaning) 
               VALUES ($1, $2, $3, $4, $5) 
               ON CONFLICT DO NOTHING`,
              [symbol.name, symbol.description, symbol.image_url, symbol.bible_references, symbol.meaning]
          );
      }

      res.json({ success: true, message: 'Symboles initialisés' });
  } catch (error) {
      res.status(500).json({ success: false, error: error.message });
  }
});